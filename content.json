{"meta":{"title":"Web","subtitle":"","description":"","author":"gslience","url":"https://github.com/gslience/gslience.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-06-22T15:04:49.589Z","updated":"2020-06-22T15:04:49.589Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/gslience/gslience.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-22T15:05:21.268Z","updated":"2020-06-22T15:05:21.268Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/gslience/gslience.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"nodeJs_basic","slug":"nodeJs-basic","date":"2020-06-11T04:29:01.000Z","updated":"2020-07-04T11:11:35.532Z","comments":true,"path":"2020/06/11/nodeJs-basic/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/06/11/nodeJs-basic/","excerpt":"","text":"事件驱动模型 nodeJS 是单线程，单进程的程序，需要事件驱动来处理异步，事件机制是观察者模式 eventEmitters(产生的实例是事件对象)生成事件，放进events(任务队列)， 事件循环(event loop)每次取一个事件任务，这个事件任务经过循环进入 events handlers(事件句柄)。event loop都是不断循环，直到任务队列清空或者处理的任务达到系统上限 12345678910111213141516// 引入Event模块并创建eventsEmmitter对象var events = require('events');var eventEmitter = new events.EventEmitter();// 绑定事件处理函数var connectHandler = function connected() &#123; console.log('connected被调用！')&#125;// 完成事件绑定eventEmitter.on('connection', connectHandler()); // 触发事件eventEmitter.emit('connection');console.log('程序执行完毕') 模块化 概念和意义 a. 为了让代码语言可以相调用 b. 文件和模块是一一对应的，一个node.js文件是一个模 c. 这个文件可以是js文件，json文件或者编译过的c/c++扩展 d. node.js中存在4类模块(原生模块和3种文件模块) e. 导出用module.exports， 导入用require 模块加载流程 小结： 首先从文件模块缓存中查找，在缓存里就加载，不在文件模块缓冲区，则判断文件是否是原生模块，是就从原生模块加载， 不是原生模块， 从文件模块加载","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://github.com/gslience/gslience.github.io/tags/node/"}]},{"title":"js手写代码","slug":"JS-hand-crafted-code","date":"2020-06-11T02:57:44.000Z","updated":"2020-06-22T14:14:19.504Z","comments":true,"path":"2020/06/11/JS-hand-crafted-code/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/06/11/JS-hand-crafted-code/","excerpt":"","text":"用ES5实现一个Promise promise 特性： 状态单一，状态一旦改变就不可逆转，异步回调，可以使用then来做链式调用， 避免回调地狱，使代码比较清晰 缺陷：promise的错误会在内部被吞掉， promise一旦创建，无法取消 1234567891011121314151617181920212223242526272829303132333435function Promise(fn) &#123; var self = this; self.status = 'pendding'; self.reason = ''; self.value = ''; function resolve(value) &#123; if(self.status === 'pendding') &#123; self.status = 'resolved'; self.value = value; &#125; &#125; function reject(err) &#123; if(self.status === 'pendding') &#123; self.status = 'rejected'; self.reason = err; &#125; &#125; try&#123; fn(resolve, reject) &#125; catch(err) &#123; reject(err) &#125; return self;&#125;// 链式操作Promise.prototype.then = function (onResolved, onRejected) &#123; var self = this; if (self.status === 'resolved') &#123; onResolved(self.value); &#125; else if (self..status === 'rejected') &#123; onRejected(self.reason); &#125;&#125; 实现instanceOf a instanceof b 返回布尔值，判断a是否是b的实例 实现思路：顺着a的原型链往上找， 比较a原型链上的原型对象与b的原型对象相等，一直找到Object的prototype， Object.prototype指向null 12345678910function instanceof(left, right) &#123; let proto = left.__proto__; let prototype = right.prototype; while(true) &#123; if (proto === null) return false; if (prototype === proto) return true; proto = proto.__proto__; &#125;&#125;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/gslience/gslience.github.io/tags/JS/"}]},{"title":"NodeJs的事件循环机制与浏览器的事件循环机制","slug":"event-loop","date":"2020-05-25T10:08:59.000Z","updated":"2020-06-22T14:48:27.479Z","comments":true,"path":"2020/05/25/event-loop/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/05/25/event-loop/","excerpt":"","text":"javaScript是单线程的脚本语言 多线程有很多复杂性，比如： 多线程操作dom就会有很多复杂性，例如： 一个线程是删除dom，另一个线程更新同一个dom，这就造成冲突。 为避免这种情况的出现，JS是单线程的，另外JS的执行和运行是分开的，执行是依赖环境的，在node环境和浏览器环境下执行有区别。 eventLoop在浏览器环境下 浏览器执行js时，会分配一块堆内存(heap)和栈内存(stack), heap主要是用来存放类似对象的引用类型数据，stack是存放值类型、执行代码的。有一些任务是异步的，浏览器又是单线程的，如果不做处理，浏览器会等异步结果返回再往下执行，这会导致浏览器出现卡死的情况。为了避免这种情况的出现，浏览器会把创建一个任务队列函数，执行代码过程中若遇到异步任务，就把异步任务放进任务队列中，执行栈往下执行，执行栈执行完毕之后，去检查任务队列有没有已返回结果的，如果有执行任务队列中的任务，接下来执行异步任务中的任务，如果没有就等待。 浏览器中，异步任务队列有分宏任务和微任务， 宏任务的优先级比微任务的优先级底，宏任务有setTimeout,setInterval,script, requestAnimationFrame， 微任务有promise和mutationObserver。 例子： 1234567891011121314151617181920// 1.宏任务和微任务的执行顺序setTimeOut(() =&gt; &#123; console.log('timeout');&#125;, 0);const promise = new Promise(resolve =&gt; &#123; console.log('promise init'); resolve(1); console.log('promise end');&#125;);promise.then(res =&gt; &#123; console.log('promise reault:', res);&#125;)// 结果：// promise init// promise end// promise reault:1// timeout 12345678910111213141516171819// 2.宏任务和微任务的交错执行setTimeOut(() =&gt; &#123; console.log('timeout1'); Promise.resolve().then(() =&gt; &#123; console.log('promise1'); &#125;);&#125;, 0);Promise.resolve().then(() =&gt; &#123; console.log('promise2'); setTimeOut(() =&gt; &#123; console.log('timeout2'); &#125;, 0);&#125;)// 结果：// promise2// timeout1// promise1// timeout2 1234567// 3.async await 拆解1async function fn() &#123; return await 1234; // 相当于 return Promise.reslove(1234);&#125;fn().then(res =&gt; console.log(res));// 结果：// 1234 123456789101112// 4.async await 拆解2 await thenableasync function fn() &#123; return await (&#123; then(resolve) &#123; resolve(1234); &#125; &#125;)&#125;// 遇到thenable, 会递归使用promise.then调用， 直到resolve返回一个值fn().then(res =&gt; console.log(res));// 结果：// 1234 1234567891011121314151617181920212223// 5.使用async await 顺序判断(将async转换成我们熟悉的promise)async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end'); // 上面两行代码 相当于 // new Promise(resolve =&gt; &#123; // console.log('async2') // resolve() // &#125;).then(res =&gt; console.log('async1 end'));&#125;async function async2() &#123; console.log('async2')&#125;async1();console.log('script');// 结果：// async1 start// async2// script// async1 end 12345678910111213141516171819// 6.如果promise没有resolve或rejectasync function async1() &#123; console.log('async1 start'); await new Promise(resolve =&gt; &#123; console.log('promise1')// 没有执行resolve, promise状态没有变， await后面的代码不会执行 &#125;) return 'async1 end'&#125;console.log('script start');async1().then(res =&gt; console.log(res));console.log('script end');// 结果：// script start// async1 start// promise1// script end// async1 end (不执行) 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 7.某大厂真是面试题async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function () &#123; console.log('setTimeout');&#125;, 0);async1();new Promise(function (resolve) &#123; console.log('promise1') resolve()&#125;).then(function () &#123; console.log('promise2')&#125;).then(function () &#123; console.log('promise3')&#125;).then(function () &#123; console.log('promise4')&#125;);console.log('script end');// 结果：// script start// async1 start// async2// promise1// script end// async1 end ??// promise2// promise3// promise4// setTimeout 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 8.第七题的升级async function async1() &#123; console.log('async1 start'); return new Promise(resolve =&gt; &#123; // resolve处理thenable也会在包裹一层promise， 会导致代码延迟一个微任务执行 resolve(async2()); &#125;).then(() =&gt; &#123; console.log(\"async1 end\") &#125;)&#125;// async函数 也会返回一个promise，会延迟一个微任务执行function async2() &#123; // async是一个promise console.log('async2'); // return &#123;then(r)&#123;r()&#125;&#125; // 有thenable返回，跟async一样， 会延迟一个微任务执行 // 返回普通值，不延迟执行&#125;setTimeout(function () &#123; console.log('setTimeout');&#125;, 0);async1();new Promise(function (resolve) &#123; console.log('promise1') resolve()&#125;).then(function () &#123; console.log('promise2')&#125;).then(function () &#123; console.log('promise3')&#125;).then(function () &#123; console.log('promise4')&#125;);// 结果：// 1.async2为async函数// async1 start// async2// promise1// promise2// promise3// async1 end// promise4// setTimeout// 2.async2不是async函数// async1 start// async2// promise1// async1 end// promise2// promise3// promise4// setTimeout eventLoop在node环境下的环境下 nodejs有四层结构：应用层，v8引擎(解析js的语法)，node API层，libuv层(实现文件操作，事件循环， 实现异步的核心) nodejs的I/O操作都是在线程池中指定某一线程执行的，nodejs的主线程主要负责调度，执行事件循环中的任务，即主线程只执行同步操作 event-loop在node中有六个阶段， 每个阶段完成之后，会查询微任务队列(nodejs的微任务有process.nextTick、promise等)，如果有待完成的任务，则执行完微任务， 微任务执行完之后才会进入下一阶段, 详情如下: a. timer阶段: 执行已经到期的定时器的回调函数 b. pending callbacks阶段： 某些系统操作（例如TCP错误类型） 的回调函数 c. idle,prepare阶段：node内部使用（准备工作） d. poll轮询阶段: I/O操作的回调 过程： 如果轮询队列不为空，则取队列中第一个回调函数，直到队列为空或者达到系统最大限度 如果轮询队列为空 如果之前设置过setImmediate，则进入下一个check阶段, 如果没有设置过setImmediate, 在当前poll阶段等待 直到轮询队列添加回调函数，就执行回调函数 如果定时器到点了，也会去下一个阶段 e. check阶段： 执行setImmediate回调 f. close callbacks阶段： 执行close事件回调， 比如TCP断开连接 废话不多说，上题 比较setImmedidate 与 setTimeout 执行顺序 1234// 执行顺序不固定 因为setTimeout加入timer需要时间，当代码执行时，setTimeout不在timer里面，则先执行setImmediate, 否则先执行setTimeout；setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate')); 1234567// 如果两者都在同一个poll阶段注册， 那么执行顺序就能确定 先执行setImmdidate, 再执行setTimeout, 原因： poll阶段注册回调时间，往下走到check阶段，执行setImmediate, 接着进入timer阶段，定时器到期， 执行setTimeoutconst fs = require('fs');fs.readfile('./readme.md', () =&gt; &#123; setTimeout(_ =&gt; console.log('setTimeout')); setImmedidate(_ =&gt; console.log('setImmedidate'));&#125;) 123456789101112// 理解process.nextTick// 每一个阶段执行完成之后，在当前阶段尾触发 nextTick // 案例：常见的nodejs回调函数第一个参数，都是抛出的错误// 原因：因为nodejs是基于回调式的写法，process.nextTick的作用是处理本阶段的错误，返回err对象，防止主线程崩掉，让主线程正常执行function apiCall(arg, callback) &#123; if (typeof arg !== 'string') &#123; return process.nextTick( callback, new TypeError('argument should be string') ); &#125;&#125; 12345678910111213// 比较process.nextTick 和 setImmediate// process.nextTick() 在同一个节点尾部立即执行// setImmediate()在事件循环的check阶段出发// 结果： nextTick setImmediate setImmediate(() =&gt; &#123; console.log('setImmediate')&#125;)process.nextTick(() =&gt; &#123; console.log('nextTick')&#125;) eventLoop在node 11之前与node11之后的比较 123456789101112131415161718// timer 阶段的执行时机变化setTimeout(() =&gt; &#123; console.log('timer1'); Promise.resolve().then(function () &#123; console.log('promise1'); &#125;)&#125;)setTimeout(()=&gt;&#123; console.log('timer2'); Promise.resolve().then(function () &#123; console.log('promise2'); &#125;)&#125;)// 结果// &lt; node11: timer1 timer2 promise1 promise2// &gt;= node11: timer1 promise1 timer2 promise2 1234567891011121314// check 阶段的执行时机变化setImmediate(() =&gt; console.log('immediate1'));setImmediate(() =&gt; &#123; console.log('immediate2') Promise.resolve().then(() =&gt; console.log('promise resolve'))&#125;)setImmediate(()=&gt; console.log('immediate3'))setImmddiate(() =&gt; console.log('immediate4'))// 结果// &lt; node11: immediate1 immediate2 immediate3 immediate4 promise resolve// &gt;= node11: immediate1 immediate2 promise resolve immediate3 immediate4 1234567891011121314// nextTick 队列的执行时机变化setImmediate(() =&gt; console.log('timeout1'));setImmediate(() =&gt; &#123; console.log('timeout2') process.nextTick(() =&gt; console.log('next tick'))&#125;)setImmediate(()=&gt; console.log('timeout3'))setImmddiate(() =&gt; console.log('timeout4'))// 结果// &lt; node11: itimeout1 timeout2 timeout3 timeout4 next tick// &gt;= node11: timeout1 timeout2 next tick timeoute3 itimeout4 总结: node node11版本之前 一旦执行一个阶段， 会先将这个阶段里的所有任务执行完成之后，才会执行该阶段剩下的微任务 node11版本之后 一旦制定一个阶段里的一个宏任务，就立刻执行对应的微任务队列 浏览器的任务队列的执行顺序node11版本之后基本一致 References [1] [https://blog.csdn.net/li420520/article/details/82900716] [2] [https://zhuanlan.zhihu.com/p/88770385]","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/gslience/gslience.github.io/tags/js/"}]},{"title":"实现图片的预览、压缩和上传","slug":"img-preview-compress-upload","date":"2020-05-25T02:12:56.000Z","updated":"2020-06-22T14:14:06.115Z","comments":true,"path":"2020/05/25/img-preview-compress-upload/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/05/25/img-preview-compress-upload/","excerpt":"","text":"详见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// input type=file的change事件function handleImgChange(e) &#123; let file = e.target.files[0]; if (file.type.indexOf('image') === -1) &#123; this.$toast('请选择图片'); &#125; else &#123; let reader = new FileReader(); reader.onLoad = function () &#123; // this.result // 读取的文件内容 // 大于2M进行压缩 if (file.size &gt;= 1024*1024*2) &#123; compressImage(path, &#123;quality: 0.3&#125;, (base64) =&gt; &#123; let fileBuffer = processData(base64, file.type); upload(fileBuffer, file.name); &#125;) // 小于2M不压缩 &#125; else &#123; upload(file, file.name); &#125; &#125; &#125;&#125;// 图片上传到服务器function upload(file, name) &#123; let formData = new FormData(); formData.append('file', file, name); $.ajax(&#123; type: 'post', url: 'xxx', header: &#123; contentType: 'multipart/form-data' &#125;, // 以下两个属性必须加上， 否则zepto会对formdata进行非原生处理 processData: false, contentType: false, dataType: 'json', success: res =&gt; &#123; console.log('图片上传成功', res) &#125;, fail: res =&gt; &#123; console.log('图片上传失败', res) &#125; &#125;)&#125;// 压缩图片 通过canvas.toDataURL的第二参数，quality，值为0~1function compressImage(path, obj, callback) &#123; let img = new Image(); img.src = path; img.onload = function () &#123; let that = this; // 按比例压缩 let w = that.width, h = that.height, scale = w / h; w = obj.width || w; h = obj.height || (w / scale); // 生成canvas const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'); canvas.width = w; canvas.height = h; // 默认的压缩比例 let quality = 0.7; if (obj.quality &amp;&amp; obj.quality &lt;= 1 &amp;&amp; obj.quality &gt; 0) &#123; quality = obj.quality; &#125; const base64 = canvas.toDataURL('image/jpeg', quality); callback &amp;&amp; callback(base64); &#125; // 将base64转换成二进制文件流 function processData(dataUrl, type, name) &#123; let binaryString = window.atob(dataUrl.split(',')), arrayBuffer = new ArrayBuffer(bindaryString.length), intArray = new Uint8Array(arrayBuffer); for (let i=0, len = bindaryString.length; i &lt; len; i++) &#123; intArray[i] = binaryString.charCodeAt(i); &#125; let data = [intArray], blob; try&#123; blob = new Blob(data, &#123;type&#125;, name); &#125; catch(e) &#123; // 低版本浏览器的兼容 window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder; if (e.name === 'TypeError' &amp;&amp; window.BlobBuilder) &#123; let builder = new BlobBuilder(); builder.append(arrayBuffer); blob = builder.getBlob(type); &#125; else &#123; // this.$toast('版本过低，不支持图片压缩上传'); &#125; &#125; return blob; &#125;&#125;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/gslience/gslience.github.io/tags/JS/"}]},{"title":"JS面试题-考点","slug":"js-basics-summary","date":"2020-05-23T07:56:23.000Z","updated":"2020-06-22T14:14:03.452Z","comments":true,"path":"2020/05/23/js-basics-summary/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/05/23/js-basics-summary/","excerpt":"","text":"块级作用域函数 1.ES6非严格模式，块级作用域函数提升变量，函数整体不会提升 2.es6严格模式或es5严格模式下，块级作用域函数变量和整体都不会提升 3.es5非严格模式下，无统一标准，各浏览器厂商不一样 this 1.arguments是类数组对象，是一个对象， 例： 1&#123;0: 1, length: 1&#125; 2.window.length指的是当前iframe的嵌套数量 3.通过arguments获取函数，进行调用，函数内部的this指向arguments, this.length取得值是arguments.length, 函数实参的个数，this.callee.length 取得值是函数参数的形参 4.Array.prototype.slice.call(arguments) 将arguments转成真正的数组 闭包 作用： 保存作用域 with会缓存所有作用域， 跳出当前作用域，拿外面作用域的变量或数据 eval实现JSON.parse方法， 会缓存作用域 前端静态资源：js,css,图片，html 图片资源的优化: webkit heishef优化 Function只作用于全局作用域 面试题 head标签中，唯一不可缺少的元素是title","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/gslience/gslience.github.io/tags/JS/"}]},{"title":"从new操作符到__proto__、prototype与constructor","slug":"JS-prototype","date":"2020-05-23T02:28:58.000Z","updated":"2020-07-04T10:59:52.391Z","comments":true,"path":"2020/05/23/JS-prototype/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/05/23/JS-prototype/","excerpt":"","text":"new操作符 1.new 操作符具体做的事情 a. 创建一个新对象 b. 新对象的[[prototype]]指向构造函数 c. 执行构造函数，并把构造函数的this指向新对象 d. 返回值如果是引用类型，直接返回， 如果是值类型，则返回对象的引用 new操作符的代码实现： 1234567891011121314151617181920// func是构造函数function New(func)&#123; let res = &#123;&#125;; if (func.prototype !== null) &#123; res.__proto__ = func.prototype; &#125; let ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if (typeof ret === \"function\" || typeof ret === \"object\" &amp;&amp; ret !== null) &#123; return ret &#125; return res;&#125;function Person(name, age) &#123; let re = &#123;name, age&#125;; return re&#125;let p = New(Person, 'test', 1);// 实际上相当于 new Person('test', 1);console.log(New(Person, 'test', 1)) // &#123;name: 'test', age: 1&#125; new操作符关键的步骤是把新对象的__proto__指向传入的构造函数， 这里涉及到原型链的知识，请看下面 constructor、__proto__与prototype 每个构造函数都具有一个属性叫prototype，这个属性指向构造函数的原型对象，构造函数的原型对象有一个constructor的属性指向构造函数，构造函数的实例有一个[[prototype]]的属性，这是浏览器内核的属性，值得注意的是Object的原型对象， 即Object.prototype.__proto__指向null。 具体关系如下图， 1.f1,f2都是构造函数Foo的实例，具有__proto__这个属性，指向Foo.prototype(构造函数的原型对象), 构造函数Foo的prototype属性指向Foo.prototype(构造函数的原型对象), Foo.prototype(构造函数的原型对象)的属性constructor指向构造函数Foo。o1,o2、Object与Object.prototype的关系类似，不过多阐述 2.构造函数Foo是Function的实例，因此Foo的属性__proto__指向Function.prototype(构造函数的原型对象); Foo.prototype又是一个对象，是Object的实例，因此Foo.prototype的__proto__指向Object.prototype(构造函数的原型对象) 3.构造函数Object是Function的实例，因此Object的属性__proto__指向Function.prototype, Function.prototype又是一个对象，是Object的实例，因此Function.prototype的__proto__指向Object.prototype(构造函数的原型对象) 4.Function的__proto__指向其构造函数的原型，Function又是Function构造出来的，因此Function的__proto__指向Function.prototype 总结： 实例的隐式原型等于构造函数的显式原型， 只有普通函数有显式原型(prototype)（剪头函数和bind函数没有显式原型，剪头函数没有this），所有对象都有隐式原型(__proto__) 继承的写法 1234567891011121314151617181920212223function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.run = function () &#123; console.log(this.name);&#125;funciton Student(name, age, grade) &#123; Student.call(this, name, age, grade);&#125;Student.prototype = Object.create(Person.prototype, &#123; constructor: &#123; value: Student &#125;&#125;);var stu = new Student('test', 1, '一年级');console.log(stu.run())；console.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // true","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/gslience/gslience.github.io/tags/js/"}]},{"title":"ES7 ES8新特性","slug":"js","date":"2020-05-21T07:12:34.000Z","updated":"2020-06-22T14:16:22.777Z","comments":true,"path":"2020/05/21/js/","link":"","permalink":"https://github.com/gslience/gslience.github.io/2020/05/21/js/","excerpt":"","text":"ES7 数组的includes方法，判断特定的元素是否在数组中，返回Boolean值， 用法: 123[1, 2, 3, 4].includes(2); // true[1, 2, 3, 4].includes(8); // false 之前通过indexOf来判断元素是否存在数组中： 1[1, 2, 3, 4].indexOf(2) &gt; -1; // true Math.pow的简写， 用法: 12console.log(Math.pow(2, 3));console.log(2 ** 3); ES8 async和await处理异步 async函数的返回值是一个promise 前端处理异步的方法 1.嵌套调用 2.Promise 3.Generators(ES6) 4.async和await(重点介绍) 1234567async function add(n) &#123; return n + 1;&#125;add(4).then(res =&gt; &#123; console.log(res); // 5&#125;) 123456789101112function promiseFn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('result'); &#125;, 1500) &#125;)&#125;async function fn() &#123; let res = await promiseFn(); console.log('异步代码执行完毕', res)&#125;fn(); await只能在async函数中使用， await是等待一个异步程序的运行结果， 后面的程序的执行得等结果返回之后 以下正常的写法，无法捕获到程序错误, 程序中断， 数据结构的一致性很可能被破坏 123456789101112function promiseFn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('错误信息err'); &#125;, 1500) &#125;)&#125;async function fn() &#123; let res = await promiseFn(); console.log(res);&#125;fn(); 捕获错误的处理： 1.使用try-catch 12345678910111213141516function promiseFn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('错误信息'); &#125;, 1500) &#125;)&#125;async function fn() &#123; try&#123; let res = await promiseFn(); console.log('异步代码执行完毕', res); &#125;catch(err) &#123; console.log(err); // 错误信息被捕获了 &#125;&#125;fn(); 2.使用Promise提供的catch 1234567891011121314151617181920212223function awaitWrap (promise) =&gt; &#123; return promise.resolve(() =&gt; [null, data]) .catch(() =&gt; [err, null])&#125;function promiseFn() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('错误信息'); &#125;, 1500) &#125;)&#125;async function fn() &#123; // 普通 let res = await promiseFn().catch(err =&gt; &#123; console.log(err); &#125;); console.log('异步代码执行完毕', res); // 抽离错误处理方法 let [err, data] = await awaitWrap(promiseFn()); console.log(err, data)&#125;fn(); 多个await之间的代码互不依赖 使用promise.all 12345678910111213141516171819202122232425262728function promiseFn1() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('fn1'); &#125;, 1000) &#125;)&#125;function promiseFn2() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('fn2'); &#125;, 2000) &#125;)&#125;async function fn1() &#123; console.time('fn1') await promiseFn1(); await promiseFn2(); console.timeEnd('fn1') async function fn2() &#123; console.time('fn2') await Promise.all([promiseFn1(), promiseFn2()]); console.timeEnd('fn2') &#125;fn1(); // fn1: 3003.1640625msfn2(); // fn2: 2000.994873046875ms&#125; Object.values()和Object.keys(), es8之前遍历一个对象，需要用到Object.keys() 1234567const obj = &#123;name: 'test', age: 5&#125;;// 之前console.log(Object.keys(obj).map(key =&gt; obj[key])); // ['test', 5]// ES8console.log(Object.values(obj)); // ['test', 5] Object.entries() vs for…in(会枚举原型链中的属性) Object.entries()传入的参数不是对象会被转成对象 12345678910111213const obj = &#123;name: 'test', age: 5&#125;;console.log(Object.entries(obj)); // [['name', 'test], ['age', 5]]// 获取对象的键值对for(const [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; - $&#123;value&#125;`)&#125;Object.entries(obj).forEach(([key, value]) =&gt; &#123; console.log(`$&#123;key&#125; - $&#123;value&#125;`)&#125;) 字符串的操作方式，前面插入字符串：padStart(), 追加字符串： padEnd() String.prototype.padStart(targetLength, [padString]); // targetLength 目标长度，即是追加之后字符串的长度 padString 追加的字符串 12345'123'.padStart(4, '90'); //9123'123'.padStart(1); //123'123'.padStart(10); // 123 缺省值是空格 结尾允许逗号 方便多人协作、代码的版本管理 123456789101112// 之前const obj1 = &#123; q: '', b: '', a: ''&#125;// ES8支持const obj2 = &#123; q: '', b: '', a: '',&#125; Object.getOwnPropertyDescriptors() 获取对象属性 12345678// 之前const obj = &#123; name: 'yideng', get fn() &#123; return 'fn'; &#125;&#125;;console.log(Object.getOwnPropertyDescriptors(obj))","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://github.com/gslience/gslience.github.io/tags/JS/"}]}],"categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://github.com/gslience/gslience.github.io/tags/node/"},{"name":"JS","slug":"JS","permalink":"https://github.com/gslience/gslience.github.io/tags/JS/"},{"name":"js","slug":"js","permalink":"https://github.com/gslience/gslience.github.io/tags/js/"}]}